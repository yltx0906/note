一、Java的基本介绍
1、java运行需要的环境：jdk(jre(jvm)

   jvm： java虚拟机，是JRE的一部分，提供的一些机制有
 		 1）字节码校验器：需要叫个jvm去处理执行java文件
  	 	 2）垃圾回收机制：清除不再使用的对象,释放垃圾占用的空间
   jre：基本类库 运行环境
   jdk：运行工具  java开发工具包，是整个java核心，包括了java运行环境

2、安装JDK后，需要配置的三个环境变量分别是什么？以及每个环境变量代表的含义是什么？

   javahome   ：jdk的安装路径

   classpath ： 当前要执行的java类（class文件）所在路径

   path  ： 	jdk中bin目录所在路径


3、java语言中的"Write once, Run anywhere"指的是什么？为什么？
	
	一次编写，到处运行。

	因为不同平台中有不同的JVM，可以把相同的class文件解释成该平台中所对应的指令去执行。

4、执行一个普通java类（有主函数）时，一般会涉及到哪些类加载器？CLASSPATH和哪一个类加载器有关系？什么关系？
	
参考答案:	
	启动类加载器
	扩展类加载器
	应用类加载器

	CLASSPATH和应用类加载器有关系

	应用类加载器会通过CLASSPATH中配置的路径，来查找当前需要执行的java代码所存在的class文件


5、类加载器加载了字节码文件之后，会对该文件做字节码校验，请列出几条校验的方面

	字节码版本和JVM是否兼容
	代码不能破坏系统的完整性
	运行时堆栈没有溢出
	参数类型是否正确
	类型转换是否正确
	变量要在使用之前进行初始化
	方法调用与对象引用类型间要匹配

6、请任意写出编译运行的命令？

	javac -d bin src/Student.java
	javac -d bin src/StudentTest.java
	java -cp bin com.briup.StudentTest

7、java程序中，如何给对象申请内存，如何释放不再使用的对象内存？
	
       通过new关键字给要创建的对象申请内存空间（基本数据类型除外），所有的对象都是在堆中分配空间
       当一个对象不再被使用（没有引用指向它）时，会被标记为垃圾，再之后的某个时刻，会被垃圾回收器(GC)进行内存的释放

8、java中的三种注释分别是什么？把class文件反编译后是否可以获取代码中的注释？
	
参考答案:
	单行注释	//
	多行注释	/* */
	文档注释	/** */
	
	不能

9、 etc： 保存的是你所安装软件关键的启动文件和配置文件
    opt： 用来保存程序文件的

10、java特性：跨平台、多线程








二、标识符
1、java中的标识符指的是什么？
	
参考答案:
	类的名字、方法的名字、变量的名字


2、四类：数值类型（整数型，浮点型），字符类型，逻辑类型

    基本类型变量：字节型char，整型int，长整型long，短整型short，浮点型（单float/双double精度型）			  布尔类型boolean
 
    引用类型变量：类类型，接口类型，数组类型


3、int类型能表示整数的最小值和最大值分别是多少？可以用次方数来表示

参考答案:     -2的31次方---2的31次方-1


4、java中整型默认类型是int,浮点型默认类型是double,那么以下俩句代码会不会编译出错?为什么?
	byte b = 1;
	float f = 10.5;

参考答案
	编译会出错,因为10.5默认是double类型的,double类型是双精度的浮点数,float是单精度的浮点数,双精度的数字如果用单精度的变量接收有可能会丢失精度的。

5、基本数据类型和引用数据类型的基本特点：

 概念上：基本数据类型变量名指向具体的数值
  	 引用数据类型变量名指向存数据对象的内存地址

 使用上：基本数据类型使用时需要赋具体值,判断时使用“==”号
 	 引用数据类型使用时可以赋null,判断时使用equals方法


6、实例变量(全局变量，成员变量，静态变量，叫法不一样)和局部变量的特点，从声明位置、有无默认值、    作用范围等方面分别说明

参考答案:	
	实例变量，声明在类中，有默认值、作用范围是整个类中
	局部变量，声明在方法中，没有默认值(使用前要初始化)、作用范围是从该变量声明开始，到最近的一个大括号结束

        实例变量存在于堆内存的对象中。随着对象的创建而存在，随着对象的消失而消失。
        局部变量存在于栈内存的方法中。随着所属区域的执行而存在，随着所属区域的结束而释放。

7、在java中，&&和&有什么分别	

参考答案:	
	&既可以用作位运算，又可以用作逻辑运算。

	&&只能用作逻辑运算，具有短路的特点，第一个布尔表达式的结果如果能决定整个逻辑运行的结果，则后面的布尔表达式不再运算

8、什么是值传递和引用传递？

	他们本质上相同
	值传递传递的是变量的值，引用传递传递的是对象的地址
    1) 值传递:  对于基本数据类型，参数通过值传递。(把实参的值复制一份再传给形参)
    2) 引用传递:对于引用类型，参数通过引用(对象的引用)传递。(实参自身存放的堆区内存地址值复制一		份传给方法的形参）

9、











三、运算符

1、获取三个整数中的最大值
     int a ,b,c 
     int num =(x>y)?x:y;
     int result = (num>z)?num:z;

2、在java中，&&和&有什么分别	

参考答案:	
	&既可以用作位运算，又可以用作逻辑运算。

	&&只能用作逻辑运算，具有短路的特点，第一个布尔表达式的结果如果能决定整个逻辑运行的结果，则后面的布尔表达式不再运算


3、













四、流程控制

1、break、return、continue的区别和用法：

   1）break：借助标号中断任意一层循环，不借助标号直接跳出当前的循环,只能跳出一层循环
   2）return： 中止当前函数的运行，不在执行后面的语句，并将操作权返回给调用者，不一定要返回一个值
   3）continue：终止当前的循环过程，但他并不跳出循环,而是继续往下判断循环条件执行语句

2、 for循环适合针对一个范围判断进行操作；
    while循环适合判断次数不明确操作；




四、数组
1、java中的数组对象和java.util.Arrays类是什么关系?	

参考答案：
    array： 提供了动态创建和访问 Java 数组的方法。其中的元素的类型必须相同。效率高，但容量固定
    arrays：静态类专门用来操作array ，提供搜索、排序、复制、查找数组中某个元素的下标等静态方法。


2、假设有一个数组对象arr，如何获取该数组的长度？使用该数组对象可以调用到哪些方法？
参考答案
	int len = arr.length; 

	数组对象arr只能调用到从Object中继承过来的方法，数组对象本身并没有其他方法

3、如何复制一个数组到新数组中，使用哪个类中的哪个方法

参考答案：
      ①for循环	效率低

	int[] a = new int[] {18, 62, 68, 82, 65, 9};
    	
    	
	int[] b = new int[3];//分配了长度为3的空间，但没有赋值
    	

    	//通过数组赋值把 a数组的前3位赋值到b数组
    	
   
    	for (int i = 0; i < b.length; i++) 
   
 	{
    		b[i] = a[i];
    	}


      ②使用Arrays类中的copyOf方法
	
	使用System类中的arraycopy方法	   推荐使用	
	 int[] a1={1,2,3,4,5,6,7};  
         int[] a2={8,9,10,11,12,13};  
           
         System.arraycopy(a1, 2, a2, 3, 2);  //a1偏移2个，a2偏移2个，拷贝a1第2个之后的两个数据
         System.out.print("copy后结果：");  
         for(int i=0;i<a2.length;i++){  
             System.out.print(a2[i]+" ");      

4、队列和栈是什么，列出它们的区别？
	
栈（Stack）是限定只能在表的一端进行插入和删除操作的线性表。
队列（Queue）是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。
队列：先进先出
栈：  先进后出

5、数组和链表和vector的区别：

    ArrayList： 基于动态数组的数据结构，增删慢，改查快
    LinkedList：基于链表的数据结构  增删快，改查慢，更适合头尾操作
    Vector ：   基于数组的数据结构，保证数据同步性，线程安全

6、三大派系：
	1）Set   无序，不能重复
	2）List  有序（放入先后的次序），添加的元素可以重复
	3）Map   中两个泛型  <   K,V  >  K:键值  V:值值
   	 Map中一个key和Value是一对键值对，一对一









四、类和对象
1、面向对象（OOP）的特征：

	封装：(Encapsulation)指对内隐藏对象的属性和实现细节，仅对外提供公共访问方式。暴露接口

	继承：(Inheritance)多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类	     	       无需再定义这些属性和行为，只要继承那个类即可。

	多态：(Polymorphism)只看父类引用的方法，而不看子类对象的方法，
	      先成员变量再构造方法，先父类再子类

        多态表现：有同名方法执行子类的
	   三个条件： 
		①要有继承关系
		②要有方法重载
		③要有父类引用指向子类对象

           好处：提高了代码的维护性（由继承保证）
              	 提高了程序的扩展性（由多态保证）
	   弊端：不能访问子类特有功能
	抽象：
ps：对对象的要求：高内聚，低耦合

2、              类内部（同包同类） 同包不同类 子类  其他类（不同包不同类没有继承关系）    
public                 1                1       1                1
protected              1                1       1                0
默认（default）        1                1       0                0
private                1                0       0                0


3、java面向对象、面向过程：

   面向对象就是建立一个对象，让对象帮你去做这件事
   面向过程就是做一件事，全程自己亲力亲为

4、insantanceof 怎么用
	用于判定前面所指向的对象类型是否属于后面的类型或是后面类型的子类型，是返回true，否则false
   比如：obj instanceof Student
	在运行时，引用obj所指向对象的实际类型，是不是Student类型或者Student的子类型
 注意是obj所指向的对象类型，而不是obj的类型，这个对象是否是这个Student类或者是它的子类的一个实例

5、Abstract class 和 interface有什么区别
   1).抽象类可以有构造方法，接口中不能有构造方法。
   2).抽象类中可以有普通成员变量，接口中没有普通成员变量 
   3).抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的
   4).抽象类中可以包含静态方法，接口中不能包含静态方法
   5).一个类可以实现多个接口，但只能继承一个抽象类
   6).抽象类中的静态成员变量的访问类型可以任意,但接口中定义的变量默认是public static final类型


6、方法重载和方法覆盖（方法重写）的区别：
     相同点：
        （1）方法的名称相同
	（2）都可以用于抽象方法和非抽象方法之间。
     不同点：
    1）方法重载：是一个类中多态性的一种表现， 与返回值类型和修饰符无关，只看方法名和参数列表，方法名必须相			 同，但是这个方法的参数列表必须不同（唯一判断条件）
    2）方法重写：父类与子类之间多态性的一种表现，子类重写了父类的方法返回类型，方法名，参数列表必须相同，		 访问权限不能更低
              
ps：父类的一个方法只能被子类重写一次，而一个方法在所在的类中可以被多次重载

    3）方法重写的注意事项
        父类中私有方法不能被重写；
	子类重写父类方法时，访问权限不能更低；
	子类修改父类方法时，不能修改其参数列表和返回值类型
        重写方法不能抛出新的异常，只可以抛出更少或者不抛出
    	如果一个方法不能被继承，则不能重写它
        不能重写被表示为final的方法

7、 构造器：构造方法，创建对象使用的一个特殊的方法，方法名和类名相同，没有返回值类型，void也没有
	
    构造函数：类不一定要有显示构造函数，没有时JVM会提供默认构造函数
    	
    构造方法：没有返回类型，不一定是public的方法，构造方法可以重载 

8、this关键字的作用

     ①区别成员变量和局部变量

     ②在类中可以表示当前类的对象

     ③在类的构造器中用this关键字可以调用类的其他的构造器

9、在一个类里面，静态方法中不能直接调用非静态方法，但是非静态方法中可以直接调用静态方法，为什么
参考答案	1
	因为静态方法是属于类的，在类加载的时候已经加载处理好了，可以随时使用类名来调用，而非静态方法是属于对象的，只有创建了对象之后，使用对象才能调用。当我们使用类名去调用静态方法的时候，可能还没有创建这个类的对象，那么非静态方法这时就不能调用，所有在静态方法中不能直接调用非静态方法，反之则可以。











五、集合

1、Java集合类框架的基本接口有哪些？
	①Collection：代表一组对象，每一个对象都是它的子元素。
	②Set：不包含重复元素的Collection。
	③List：有顺序的collection，并且可以包含重复元素。
	④Map：可以把键(key)映射到值(value)的对象，键不能重复。


2、HashSet和TreeSet的区别：

	TreeSet：只存储一个对象，有序且不能重复，是一个数组型的集合，内部有特定的排序方法
	TreeMap：存储两个对象(key,value)，有序可以重复，实现通过红黑树

3、HashMap和TreeMap的区别：

	TreeMap的key按自然增加顺序排序,
        HashMap没有顺序,HashMap速度快

4、collection和collections的区别：

Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。
Collection接口在Java 类库中有很多具体的实现。
Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。
Collection是集合类的上级接口，继承与他的接口主要有Set 和List.


Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。
此类不能实例化，就像一个工具类，服务于Java的Collection框架。


5、哪些集合类提供对元素的随机访问
	
	ArrayList、HashMap、TreeMap和HashTable类提供对元素的随机访问。


6、set添加元素的时候，如何判断两个对象是否相等？

	1）先比较hashCode的值，如果hashCode的值不相等，
	   不会比较equals方法，直接返回两个对象不相等。

	2）先比较hashCode的值，如果hashCode的值相等，
	   再比较equals方法，如果equals比较两个对象不相等，
	   返回这两个对象不相等。

7、为什么Set、List集合可以调用iterator方法，然后使用迭代器进行遍历，而Map集合不能使用迭代器遍历	

参考答案	
	因为Set、List集合都继承了Collection接口，而Collection接口又继承了Iterable接口，Iterable接口中提供了iterator方法，该方法可以返回一个迭代器，用来遍历集合。Map集合则没有继承该接口。

8、TreeSet本身提供两种排序方法：
      ①自然排序      升序    降序    ASCⅡ码   数字   英文大小写
      ②定制排序（客户化排序）
   两种方法：
	Comparable：接口      

	实现 Comparable 接口，重写compareTo(Object o)方法

	Comparator（比较器）：接口
	
	实例化一个Comparator接口的实现类的对象，重写compare(Object o1,Object o2)方法

9、遍历一个List有哪些不同的方式？
    Iterator,for ， 增强for
	
	Iterator it = List.iterator();
	while(i.hasNext()){
	  System.out.println();
	}





六、线程

1、进程和线程的区别是什么？
	线程是进程的一个实体, 是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.
	线程自己基本上不拥有系统资源
	一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。

	进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,
	进程是系统进行资源分配和调度的一个独立单位。
	进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响

2、Java中创建线程主要有三种方式：

       ①继承Thread类（真正意义上的线程类），是Runnable接口的实现。

       ②实现Runnable接口，并重写里面的run方法。

      // ③使用Executor框架创建线程池。Executor框架是juc里提供的线程池的实现。
ps:
   a.继承于Thread类的线程类，可以直接调用start方法启动线程（使用static也可以实现资源共享）.
   b.一个线程（对象）只能够执行一次start()，而且不能通过Thread实现类对象的run()去启动一个线程。


   c.实现Runnable接口的类需要再次用Thread类包装后才能调用start方法。
	（三个Thread对象包装一个类对象，就实现了资源共享）。

    两种创建线程的区别：

	①从语法层面来说，实现Runnable借口能够避免java的单继承原则

	②在启动代码的时候结果不一样，有随机性，还有抢占式

3、线程在执行过程中，可以处于下面五种状态：

①新建状态（New）：新创建了一个线程对象。
②就绪(Runnable):   线程准备运行，不一定立马就能开始执行。


③运行中(Running)： 进程正在执行线程的代码。



④阻塞(BlockedonI/O)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
⑤死亡(Dead)：线程完成了执行。

4、String，StringBuffer，StringBuilder的区别是什么?String为什么是不可变的

	String是字符串常量，是final类，是不可变的对象

      ①StringBuilder （没同步锁，不安全，所以最快）

	StringBuffer（有同步锁，安全）

	String（不可变性，安全）

      ②单线程下操作字符串缓冲区，选择StringBuilder最快；

	多线程下操作字符串缓冲区，选择StringBuffer最好；

5、wait和sleep和join区别
sleep()：①是Thread类的方法,可以在任何地方使用

         ②睡眠时，不释放锁，并且必须指定时间

  	 ③可以让当前线程进入阻塞状态，在指定时间内不会执行


wait():  ①wait一般都是和notify或者notifyAll成对出现的，是Object类的方法

	 ②wait和notify和notifyAll只能在同步（synchronized）控制方法或同步控制块里使用

  	 ③其他线程调用对象的notify方法前，导致当前线程等待，
	   当前线程必须要有此对象的锁，否则会抛出运行时异常

	 ④睡眠时，释放对象锁，可以指定时间也可以不指定

	 ⑤nofityAll()方法能够唤醒所有正在等待该对象的monitor的线程，这一点与notify()方法是不同的。
	
join():  ①是Thread类的方法

 	 ②因为join底层调用的是wait，所以会释放对象锁

	 ③可以使异步执行的线程变成同步，让一个线程在另一个线程结束后再执行

6、实现Runnable接口比继承Thread类所具有的优势：

1）：适合多个相同的程序代码的线程去处理同一个资源

2）：可以避免java中的单继承的限制

3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立

4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类


7、同步锁：
	对于非static方法，同步锁就是this
	对于static方法    同步锁是当前方法所在类的字节码对象

8、

9、









八、接口

1、接口可以继承接口。抽象类可以实现(implements)接口

2、Comparable和Comparator接口是什么
   1）Comparable：
	此接口强行对实现它的每个类的对象进行整体排序，此排序被称为该类的自然排序 
	，类的 compareTo方法被称为它的自然比较方法 。
   2）Comparator： （比较器）：类
	可以指定排序顺序

3、Comparable和Comparator接口有何区别？

    ①Comparator定义在Person的外部而Comparable定义在Person的内部

    ②Comparator位于包java.util下，而Comparable位于包java.lang下。

4、为何Map接口不继承Collection接口

	Map与Collection是两个不同的接口，没有继承关系。

5、interface接口：
	
	①接口里面的方法默认是抽象的，极度抽象，一个类如果实现了这个接口，必须重写这个接口里面所有的方法

	②接口里面定义的变量，默认都是public  static final 修饰，不能再修改了

	③接口中所有的方法必须都是抽象方法，没有构造方法，不能够被实例化
	
	④接口和接口之间通过继承来实现

6、抽象类和接口的区别：

-----相同点：
      都不能被实例化；
      都能包含抽象方法；

-----不同点：
      接口里面定义的应该是一些共享的功能（比如报警功能）

7、


八、抽象

1、抽象类不能使用new关键字创建对象，那么它的构造器有什么作用？
参考答案
	被子类调用






八、各种关键字的用法

1、static的用法:

	①用来修饰类的成员方法，成员变量，不能修饰类(可以修饰内部类)，
	  也可以编写static代码卡来优化程序性能

	②用来修饰代码块

2、final的用法：

	①用于类、方法以及变量（鸡肋，慎用）

	②final类中，成员方法默认是final的，成员变量不一定

	③final修饰类，该类不能子类继承

	④final修饰属性，该属性只能赋值一次

	⑤final修饰方法，该方法不能被重写

3、abstract的用法：

	①1、没有抽象构造方法，没有抽象final方法，没有抽象静态方法
	 （abstract是要求子类必须重写，static根本不存在重写），并且abstract和final、static不能连用

    	②抽象方法只能存在抽象类里面，但是抽象类里面不一定都是抽象方法，不能有方法体

	③抽象类也可以有非抽象的构造方法、抽象类可以有具体的方法

	④子类如果不是抽象类，必须重写抽象方法；是抽象类可以不重写

	⑤抽象类可以没有抽象方法，有意义，因为不想外界new抽象类新的对象

4、


七、网络

1、TCP协议socket
  开启seversocket 服务器  socket客户端
  在客户端中，开输入流
  服务器：输入输出
  创建一个tcp客户程序的顺序是：
	建立socket，获得I/O流，对I/O流进行读写操作
	关闭I/O流，关闭socket

2、网络编程三要素:

――IP

――端口

――协议  它的三要素是：语法、语义、时序。
ps：
UPI：统一资源标识符    
协议：//ip地址：端口号/资源路径
UPL：统一资源定位符

3、




九、反射
 
1、反射讲一讲，主要概念，都在哪需要反射机制，反射的性能，如何优化
    反射就是知道了类，通过方法获得这个类里面的方法、属性等等信息。
    反射的作用：在运行的时判定任意一个对象所属的类；运行时，构造任意一个类的对象；
  	        运行时，判定一个类所属的成员变量和方法；在运行时调用任意的一个方法；生成动态代理
十、I/O流

1、Java中的流都有哪些
字节流：以字节为数据单位来处理的流（Byte：8位）

字符流：以字符为数据单位来处理的流（Char：16位）

根据读写数据的单位划分，可以分为字节流和字符流。
根据功能划分：可以分为节点流和包装流。

ByteArrayInputStream 字节数组流－节点流
DataInputStream 处理JAVA标准数据流－过虑流
FilterInputStream 实现过虑流－字节过虑流父类
PipedInputStream 管道流

FileInputStream     文件字节输入流/处理文件IO流－节点流
FileOutputStream    文件字节输出流
FileReader          文件字符输入流
FileWriter	    文件字符输出流

BufferedInputStream    字节缓冲输入流   
BufferedOutputStream   字节缓冲输出流
BufferedReader	       字符缓冲输入流
BufferedWriter	       字符缓冲输出流

序列化：把Java对象转换为字节序列的过程  ObjectOutputStream      程序中的对象--------->文件 

反序列化：字节序列恢复为Java对象的过程  ObjectInputStream       文件------------->程序

ps：无论什么流，都有close()，用来关闭资源――如果我们要在程序中操作文件，就得开通一个流对象来关联文件，		    如果关闭资源，那么磁盘中的文件就一直被关联着，不能更改也不能删除。



2、InputStreamReader的作用是什么？	
参考答案
	可以把一个字节流转换为字符流，并且还可以指定字节转字符时候的编码

3、InputStream类中有如下俩个方法	
	public int read();
	public int read(byte b[]);
	分别介绍每个方法的参数和返回值的含义

参考答案
	int read() 没有参数，返回值是读到的自己流中的下一个字节值
	int read(byte b[])	参数是一个字节数组，用来存放从流中读到的字节值，直到该字节数组存满，或者读到了流的末尾，则方法结束。返回值是本次读到的字节的个数。

4、












十一、异常和枚举

1、枚举是不是类？为什么？
参考答案
	枚举是一种特殊的java类。
	枚举的class文件，使用javap命令反编译之后，可以看到，它是一个final修饰的类，并且指定了继承了java.lang.Enum父类

2、Exception和Error的区别是什么	
参考答案
	程序中出现Exception是可以处理的，并且处理后程序还可以继续执行
	程序中出现Error，是比较严重的问题，代码中无法处理，程序会终止运行。

3、Exception的分类

1）受检查的异常（编译时的异常）checked Exception
  
     IOException
     ClassNotFoundException
     DataFormatException

2）不受检查的异常（运行时异常）RuntimeException

     1. java.lang.ArithmeticException  
        算术异常	如：除0;
     2. java.lang.NullPointerException  
        空指针引用 如：没初始化一个References便使用;
     3. java.lang.ArrayIndexoutofBoundsException  
        数组越界	如：调用一个有十个元素的Array的第十一个元素的内容;
     4. java.lang.SecurityException 
        违反了java定义的安全规则
     5. java.lang.NumberFormatException  
        数据格式异常	如：Integer.parseInt("a");
     6. java.lang.NegativeArraySizeException 数组长度为负数异常 


4、如何处理异常：

	①在方法中使用try-catch 的语句块来处理异常 （处理异常）

	②不处理异常，让该方法的调用者来处理（抛出异常）

  ps：异常只能被一个异常处理器所处理, 不能声明两个
      多个catch语句块所声明的异常类型不能越来越小；




易错点：

1、一个字母=一个字节  一个汉字=一个字符=2个字节

1字节： byte , boolean    8bit 可表达 2的八次方个数字     默认值0
2字节： short , char	  16bit 可表达2的十六次方个数字
4字节： int , float       32bit
8字节： long , double	  64bit
注：1字节(byte)=8位(bits)
默认值：
boolean   false
char	  '/uoooo'(null)
byte	  (byte)0
short	  (short)0
int	      0
long	      0L
float	      0.0f
double	      0.0d

2、端口号 65536 范围0-655635  前1024被占用

3、优先级：静态代码块>匿名代码块（非静态代码块）>构造器

4、线程数问题：在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。

5、for循环适合针对一个范围判断进行操作；
   while循环适合判断次数不明确操作；

6、装箱：把基本数据类型转化为类类型
   
拆箱：把类类型转化为基本数据类型

7、Java中的==
	如果作用于基本数据类型的变量，则直接比较其存储的 “值”
	如果作用于引用类型的变量，则比较的是所指向的对象的地址

   Java中的equals
 equals方法不能作用于基本数据类型的变量，只能是一个对象来调用,然后参数也是要传一个对象的
 如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；
 诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。

8、java中整型默认类型是int,浮点型默认类型是double,那么以下俩句代码会不会编译出错?为什么?
	byte b = 1;
	float f = 10.5;

参考答案
	编译会出错,因为10.5默认是double类型的,double类型是双精度的浮点数,float是单精度的浮点数,双精度的数字如果用单精度的变量接收有可能会丢失精度的。


9、toString的用法:
	Object超类的定义就是打印类的内存地址
	重写的toString方法，一般写的是这个类的描述，所有属性的描述








GUI：
1、GUI 用户图形化界面
  几大组成部分
  1、组件 (Component）
	a、容器（Container），用来放基本组件，本身不能放在别的容器内
	b、基本组件，组件的最小组成部分
  2、布局管理器
  3、事件监听器

2、java中的事件监听机制中的三要素是什么？
参考答案
	事件源	：    组件
	事件对象：    产生的事件是什么
	监听器  ：    根据事件源产生的事件对象发生改变，执行操作

3、java的GUI中有哪些常见的布局管理器（至少列出出四种）
参考答案	
	边界布局管理器
	流式布局管理器
	网格布局管理器
	卡片布局管理器

4、如何去完成一个GUI的程序

	第一步：选择一个容器
	第二步：选择一个布局管理器：
	     FlowLayout 流式布局管理器：从左到右以此排列，如果第一行排满，自动排到下一行
	     BorderLayout 边界布局管理器：
	     GridLayout 网格布局管理器：
	     CardLayout 卡片布局管理器（选项卡）：
	第三步：根据需求创建一些组件并加入到容器当中
	第四步：添加事件监听器

5、 如果要写一个GUI，需要用到的包有什么
	java.awt.*	javax.swing.*

共同点：都存放的是GUI用到的所有组件、操作以及工具。
不同点呢：java.awt包下定义的组件风格在不同操作系统中是一样的
	  javax.swing包下定义的组件风格依据操作系统不同来进行变化，并且支持自定义

6、









